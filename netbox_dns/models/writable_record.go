// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// WritableRecord writable record
//
// swagger:model WritableRecord
type WritableRecord struct {

	// Active
	// Read Only: true
	Active *bool `json:"active,omitempty"`

	// Address record
	// Required: true
	AddressRecord *int64 `json:"address_record"`

	// Created
	// Read Only: true
	// Format: date-time
	Created *strfmt.DateTime `json:"created,omitempty"`

	// Custom fields
	CustomFields interface{} `json:"custom_fields,omitempty"`

	// Description
	// Max Length: 200
	Description string `json:"description,omitempty"`

	// Disable PTR
	//
	// Disable PTR record creation
	DisablePtr bool `json:"disable_ptr,omitempty"`

	// Display
	// Read Only: true
	Display string `json:"display,omitempty"`

	// ID
	// Read Only: true
	ID int64 `json:"id,omitempty"`

	// Last updated
	// Read Only: true
	// Format: date-time
	LastUpdated *strfmt.DateTime `json:"last_updated,omitempty"`

	// Managed
	Managed bool `json:"managed,omitempty"`

	// Name
	// Required: true
	// Max Length: 255
	// Min Length: 1
	Name *string `json:"name"`

	// PTR record
	PtrRecord *int64 `json:"ptr_record,omitempty"`

	// Status
	// Enum: [active inactive]
	Status string `json:"status,omitempty"`

	// tags
	Tags []*NestedTag `json:"tags,omitempty"`

	// TTL
	// Maximum: 2.147483647e+09
	// Minimum: 0
	TTL *int64 `json:"ttl,omitempty"`

	// Type
	// Required: true
	// Enum: [A A6 AAAA AFSDB AMTRELAY APL AVC CAA CDNSKEY CDS CERT CNAME CSYNC DHCID DLV DNAME DNSKEY DS EUI48 EUI64 GPOS HINFO HIP HTTPS IPSECKEY ISDN KEY KX L32 L64 LOC LP MB MD MF MG MINFO MR MX NAPTR NID NINFO NS NSAP NSAP_PTR NSEC NSEC3 NSEC3PARAM NULL NXT OPENPGPKEY PTR PX RP RRSIG RT SIG SMIMEA SOA SPF SRV SSHFP SVCB TA TLSA TXT TYPE0 UNSPEC URI WKS X25 ZONEMD]
	Type *string `json:"type"`

	// Url
	// Read Only: true
	// Format: uri
	URL strfmt.URI `json:"url,omitempty"`

	// Value
	// Required: true
	// Max Length: 1000
	// Min Length: 1
	Value *string `json:"value"`

	// Zone
	// Required: true
	Zone *int64 `json:"zone"`
}

// Validate validates this writable record
func (m *WritableRecord) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAddressRecord(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCreated(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDescription(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLastUpdated(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStatus(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTags(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTTL(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateURL(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateValue(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateZone(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *WritableRecord) validateAddressRecord(formats strfmt.Registry) error {

	if err := validate.Required("address_record", "body", m.AddressRecord); err != nil {
		return err
	}

	return nil
}

func (m *WritableRecord) validateCreated(formats strfmt.Registry) error {
	if swag.IsZero(m.Created) { // not required
		return nil
	}

	if err := validate.FormatOf("created", "body", "date-time", m.Created.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *WritableRecord) validateDescription(formats strfmt.Registry) error {
	if swag.IsZero(m.Description) { // not required
		return nil
	}

	if err := validate.MaxLength("description", "body", m.Description, 200); err != nil {
		return err
	}

	return nil
}

func (m *WritableRecord) validateLastUpdated(formats strfmt.Registry) error {
	if swag.IsZero(m.LastUpdated) { // not required
		return nil
	}

	if err := validate.FormatOf("last_updated", "body", "date-time", m.LastUpdated.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *WritableRecord) validateName(formats strfmt.Registry) error {

	if err := validate.Required("name", "body", m.Name); err != nil {
		return err
	}

	if err := validate.MinLength("name", "body", *m.Name, 1); err != nil {
		return err
	}

	if err := validate.MaxLength("name", "body", *m.Name, 255); err != nil {
		return err
	}

	return nil
}

var writableRecordTypeStatusPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["active","inactive"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		writableRecordTypeStatusPropEnum = append(writableRecordTypeStatusPropEnum, v)
	}
}

const (

	// WritableRecordStatusActive captures enum value "active"
	WritableRecordStatusActive string = "active"

	// WritableRecordStatusInactive captures enum value "inactive"
	WritableRecordStatusInactive string = "inactive"
)

// prop value enum
func (m *WritableRecord) validateStatusEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, writableRecordTypeStatusPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *WritableRecord) validateStatus(formats strfmt.Registry) error {
	if swag.IsZero(m.Status) { // not required
		return nil
	}

	// value enum
	if err := m.validateStatusEnum("status", "body", m.Status); err != nil {
		return err
	}

	return nil
}

func (m *WritableRecord) validateTags(formats strfmt.Registry) error {
	if swag.IsZero(m.Tags) { // not required
		return nil
	}

	for i := 0; i < len(m.Tags); i++ {
		if swag.IsZero(m.Tags[i]) { // not required
			continue
		}

		if m.Tags[i] != nil {
			if err := m.Tags[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("tags" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("tags" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *WritableRecord) validateTTL(formats strfmt.Registry) error {
	if swag.IsZero(m.TTL) { // not required
		return nil
	}

	if err := validate.MinimumInt("ttl", "body", *m.TTL, 0, false); err != nil {
		return err
	}

	if err := validate.MaximumInt("ttl", "body", *m.TTL, 2.147483647e+09, false); err != nil {
		return err
	}

	return nil
}

var writableRecordTypeTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["A","A6","AAAA","AFSDB","AMTRELAY","APL","AVC","CAA","CDNSKEY","CDS","CERT","CNAME","CSYNC","DHCID","DLV","DNAME","DNSKEY","DS","EUI48","EUI64","GPOS","HINFO","HIP","HTTPS","IPSECKEY","ISDN","KEY","KX","L32","L64","LOC","LP","MB","MD","MF","MG","MINFO","MR","MX","NAPTR","NID","NINFO","NS","NSAP","NSAP_PTR","NSEC","NSEC3","NSEC3PARAM","NULL","NXT","OPENPGPKEY","PTR","PX","RP","RRSIG","RT","SIG","SMIMEA","SOA","SPF","SRV","SSHFP","SVCB","TA","TLSA","TXT","TYPE0","UNSPEC","URI","WKS","X25","ZONEMD"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		writableRecordTypeTypePropEnum = append(writableRecordTypeTypePropEnum, v)
	}
}

const (

	// WritableRecordTypeA captures enum value "A"
	WritableRecordTypeA string = "A"

	// WritableRecordTypeA6 captures enum value "A6"
	WritableRecordTypeA6 string = "A6"

	// WritableRecordTypeAAAA captures enum value "AAAA"
	WritableRecordTypeAAAA string = "AAAA"

	// WritableRecordTypeAFSDB captures enum value "AFSDB"
	WritableRecordTypeAFSDB string = "AFSDB"

	// WritableRecordTypeAMTRELAY captures enum value "AMTRELAY"
	WritableRecordTypeAMTRELAY string = "AMTRELAY"

	// WritableRecordTypeAPL captures enum value "APL"
	WritableRecordTypeAPL string = "APL"

	// WritableRecordTypeAVC captures enum value "AVC"
	WritableRecordTypeAVC string = "AVC"

	// WritableRecordTypeCAA captures enum value "CAA"
	WritableRecordTypeCAA string = "CAA"

	// WritableRecordTypeCDNSKEY captures enum value "CDNSKEY"
	WritableRecordTypeCDNSKEY string = "CDNSKEY"

	// WritableRecordTypeCDS captures enum value "CDS"
	WritableRecordTypeCDS string = "CDS"

	// WritableRecordTypeCERT captures enum value "CERT"
	WritableRecordTypeCERT string = "CERT"

	// WritableRecordTypeCNAME captures enum value "CNAME"
	WritableRecordTypeCNAME string = "CNAME"

	// WritableRecordTypeCSYNC captures enum value "CSYNC"
	WritableRecordTypeCSYNC string = "CSYNC"

	// WritableRecordTypeDHCID captures enum value "DHCID"
	WritableRecordTypeDHCID string = "DHCID"

	// WritableRecordTypeDLV captures enum value "DLV"
	WritableRecordTypeDLV string = "DLV"

	// WritableRecordTypeDNAME captures enum value "DNAME"
	WritableRecordTypeDNAME string = "DNAME"

	// WritableRecordTypeDNSKEY captures enum value "DNSKEY"
	WritableRecordTypeDNSKEY string = "DNSKEY"

	// WritableRecordTypeDS captures enum value "DS"
	WritableRecordTypeDS string = "DS"

	// WritableRecordTypeEUI48 captures enum value "EUI48"
	WritableRecordTypeEUI48 string = "EUI48"

	// WritableRecordTypeEUI64 captures enum value "EUI64"
	WritableRecordTypeEUI64 string = "EUI64"

	// WritableRecordTypeGPOS captures enum value "GPOS"
	WritableRecordTypeGPOS string = "GPOS"

	// WritableRecordTypeHINFO captures enum value "HINFO"
	WritableRecordTypeHINFO string = "HINFO"

	// WritableRecordTypeHIP captures enum value "HIP"
	WritableRecordTypeHIP string = "HIP"

	// WritableRecordTypeHTTPS captures enum value "HTTPS"
	WritableRecordTypeHTTPS string = "HTTPS"

	// WritableRecordTypeIPSECKEY captures enum value "IPSECKEY"
	WritableRecordTypeIPSECKEY string = "IPSECKEY"

	// WritableRecordTypeISDN captures enum value "ISDN"
	WritableRecordTypeISDN string = "ISDN"

	// WritableRecordTypeKEY captures enum value "KEY"
	WritableRecordTypeKEY string = "KEY"

	// WritableRecordTypeKX captures enum value "KX"
	WritableRecordTypeKX string = "KX"

	// WritableRecordTypeL32 captures enum value "L32"
	WritableRecordTypeL32 string = "L32"

	// WritableRecordTypeL64 captures enum value "L64"
	WritableRecordTypeL64 string = "L64"

	// WritableRecordTypeLOC captures enum value "LOC"
	WritableRecordTypeLOC string = "LOC"

	// WritableRecordTypeLP captures enum value "LP"
	WritableRecordTypeLP string = "LP"

	// WritableRecordTypeMB captures enum value "MB"
	WritableRecordTypeMB string = "MB"

	// WritableRecordTypeMD captures enum value "MD"
	WritableRecordTypeMD string = "MD"

	// WritableRecordTypeMF captures enum value "MF"
	WritableRecordTypeMF string = "MF"

	// WritableRecordTypeMG captures enum value "MG"
	WritableRecordTypeMG string = "MG"

	// WritableRecordTypeMINFO captures enum value "MINFO"
	WritableRecordTypeMINFO string = "MINFO"

	// WritableRecordTypeMR captures enum value "MR"
	WritableRecordTypeMR string = "MR"

	// WritableRecordTypeMX captures enum value "MX"
	WritableRecordTypeMX string = "MX"

	// WritableRecordTypeNAPTR captures enum value "NAPTR"
	WritableRecordTypeNAPTR string = "NAPTR"

	// WritableRecordTypeNID captures enum value "NID"
	WritableRecordTypeNID string = "NID"

	// WritableRecordTypeNINFO captures enum value "NINFO"
	WritableRecordTypeNINFO string = "NINFO"

	// WritableRecordTypeNS captures enum value "NS"
	WritableRecordTypeNS string = "NS"

	// WritableRecordTypeNSAP captures enum value "NSAP"
	WritableRecordTypeNSAP string = "NSAP"

	// WritableRecordTypeNSAPPTR captures enum value "NSAP_PTR"
	WritableRecordTypeNSAPPTR string = "NSAP_PTR"

	// WritableRecordTypeNSEC captures enum value "NSEC"
	WritableRecordTypeNSEC string = "NSEC"

	// WritableRecordTypeNSEC3 captures enum value "NSEC3"
	WritableRecordTypeNSEC3 string = "NSEC3"

	// WritableRecordTypeNSEC3PARAM captures enum value "NSEC3PARAM"
	WritableRecordTypeNSEC3PARAM string = "NSEC3PARAM"

	// WritableRecordTypeNULL captures enum value "NULL"
	WritableRecordTypeNULL string = "NULL"

	// WritableRecordTypeNXT captures enum value "NXT"
	WritableRecordTypeNXT string = "NXT"

	// WritableRecordTypeOPENPGPKEY captures enum value "OPENPGPKEY"
	WritableRecordTypeOPENPGPKEY string = "OPENPGPKEY"

	// WritableRecordTypePTR captures enum value "PTR"
	WritableRecordTypePTR string = "PTR"

	// WritableRecordTypePX captures enum value "PX"
	WritableRecordTypePX string = "PX"

	// WritableRecordTypeRP captures enum value "RP"
	WritableRecordTypeRP string = "RP"

	// WritableRecordTypeRRSIG captures enum value "RRSIG"
	WritableRecordTypeRRSIG string = "RRSIG"

	// WritableRecordTypeRT captures enum value "RT"
	WritableRecordTypeRT string = "RT"

	// WritableRecordTypeSIG captures enum value "SIG"
	WritableRecordTypeSIG string = "SIG"

	// WritableRecordTypeSMIMEA captures enum value "SMIMEA"
	WritableRecordTypeSMIMEA string = "SMIMEA"

	// WritableRecordTypeSOA captures enum value "SOA"
	WritableRecordTypeSOA string = "SOA"

	// WritableRecordTypeSPF captures enum value "SPF"
	WritableRecordTypeSPF string = "SPF"

	// WritableRecordTypeSRV captures enum value "SRV"
	WritableRecordTypeSRV string = "SRV"

	// WritableRecordTypeSSHFP captures enum value "SSHFP"
	WritableRecordTypeSSHFP string = "SSHFP"

	// WritableRecordTypeSVCB captures enum value "SVCB"
	WritableRecordTypeSVCB string = "SVCB"

	// WritableRecordTypeTA captures enum value "TA"
	WritableRecordTypeTA string = "TA"

	// WritableRecordTypeTLSA captures enum value "TLSA"
	WritableRecordTypeTLSA string = "TLSA"

	// WritableRecordTypeTXT captures enum value "TXT"
	WritableRecordTypeTXT string = "TXT"

	// WritableRecordTypeTYPE0 captures enum value "TYPE0"
	WritableRecordTypeTYPE0 string = "TYPE0"

	// WritableRecordTypeUNSPEC captures enum value "UNSPEC"
	WritableRecordTypeUNSPEC string = "UNSPEC"

	// WritableRecordTypeURI captures enum value "URI"
	WritableRecordTypeURI string = "URI"

	// WritableRecordTypeWKS captures enum value "WKS"
	WritableRecordTypeWKS string = "WKS"

	// WritableRecordTypeX25 captures enum value "X25"
	WritableRecordTypeX25 string = "X25"

	// WritableRecordTypeZONEMD captures enum value "ZONEMD"
	WritableRecordTypeZONEMD string = "ZONEMD"
)

// prop value enum
func (m *WritableRecord) validateTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, writableRecordTypeTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *WritableRecord) validateType(formats strfmt.Registry) error {

	if err := validate.Required("type", "body", m.Type); err != nil {
		return err
	}

	// value enum
	if err := m.validateTypeEnum("type", "body", *m.Type); err != nil {
		return err
	}

	return nil
}

func (m *WritableRecord) validateURL(formats strfmt.Registry) error {
	if swag.IsZero(m.URL) { // not required
		return nil
	}

	if err := validate.FormatOf("url", "body", "uri", m.URL.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *WritableRecord) validateValue(formats strfmt.Registry) error {

	if err := validate.Required("value", "body", m.Value); err != nil {
		return err
	}

	if err := validate.MinLength("value", "body", *m.Value, 1); err != nil {
		return err
	}

	if err := validate.MaxLength("value", "body", *m.Value, 1000); err != nil {
		return err
	}

	return nil
}

func (m *WritableRecord) validateZone(formats strfmt.Registry) error {

	if err := validate.Required("zone", "body", m.Zone); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this writable record based on the context it is used
func (m *WritableRecord) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateActive(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateCreated(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateDisplay(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateLastUpdated(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTags(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateURL(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *WritableRecord) contextValidateActive(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "active", "body", m.Active); err != nil {
		return err
	}

	return nil
}

func (m *WritableRecord) contextValidateCreated(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "created", "body", m.Created); err != nil {
		return err
	}

	return nil
}

func (m *WritableRecord) contextValidateDisplay(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "display", "body", string(m.Display)); err != nil {
		return err
	}

	return nil
}

func (m *WritableRecord) contextValidateID(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "id", "body", int64(m.ID)); err != nil {
		return err
	}

	return nil
}

func (m *WritableRecord) contextValidateLastUpdated(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "last_updated", "body", m.LastUpdated); err != nil {
		return err
	}

	return nil
}

func (m *WritableRecord) contextValidateTags(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Tags); i++ {

		if m.Tags[i] != nil {
			if err := m.Tags[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("tags" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("tags" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *WritableRecord) contextValidateURL(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "url", "body", strfmt.URI(m.URL)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *WritableRecord) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *WritableRecord) UnmarshalBinary(b []byte) error {
	var res WritableRecord
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
